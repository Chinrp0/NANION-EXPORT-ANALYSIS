classdef NanionIOManager < handle
    %NANIONIOMANAGER Optimized file I/O for Nanion Excel files  
    %   Uses readcell() exclusively with no fallback methods
    %   Optimized for MATLAB 2025a with parallel processing support
    
    properties (Access = private)
        config
        logger
    end
    
    methods
        function obj = NanionIOManager(config, logger)
            %NANIONIOMANAGER Constructor
            
            if nargin < 2
                error('NanionIOManager:InsufficientArgs', 'Config and logger required');
            end
            
            obj.config = config;
            obj.logger = logger;
            % Note: File validation is handled internally in Phase 1
        end
        
        function rawData = readFile(obj, filePath)
            %READFILE Read Excel file using readcell() exclusively
            %   Returns raw cell array data with validation
            
            obj.logger.logInfo(sprintf('Reading file: %s', obj.getFileName(filePath)));
            
            % Pre-flight validation
            obj.validateFileForReading(filePath);
            
            tic;
            try
                % MATLAB 2025a optimized readcell call
                rawData = readcell(filePath, ...
                    'UseExcel', false, ...          % Use built-in parser (faster)
                    'EmptyFieldRule', 'missing');   % Handle empty cells as missing values
                
                readTime = toc;
                obj.logger.logInfo(sprintf('✓ File read successfully: %dx%d in %.2fs', ...
                    size(rawData, 1), size(rawData, 2), readTime));
                
                % Post-read validation
                obj.validateRawData(rawData, filePath);
                
            catch ME
                obj.logger.logError(sprintf('✗ readcell() failed for %s: %s', ...
                    filePath, ME.message));
                
                % No fallback methods per requirements - fail cleanly
                error('NanionIOManager:ReadFailed', ...
                    'File reading failed and fallbacks disabled: %s', ME.message);
            end
        end
        
        function parsedData = parseData(obj, rawData, protocolInfo)
            %PARSEDATA Parse raw data into structured format
            %   Returns structured data with headers and data sections identified
            
            obj.logger.logInfo('Parsing raw data structure...');
            
            try
                % Find header structure
                headerInfo = obj.findHeaderStructure(rawData);
                
                % Extract and validate headers
                headers = obj.extractHeaders(rawData, headerInfo);
                
                % Create structured data table
                dataTable = obj.createDataTable(rawData, headerInfo, headers);
                
                % Package results
                parsedData = struct(...
                    'dataTable', dataTable, ...
                    'headerInfo', headerInfo, ...
                    'protocolInfo', protocolInfo, ...
                    'headers', headers, ...
                    'headerRows', headerInfo.dataStartRow - 1);
                
                obj.logger.logInfo(sprintf('✓ Parsing complete: %d data rows, %d columns', ...
                    size(dataTable, 1) - parsedData.headerRows, size(dataTable, 2)));
                
            catch ME
                obj.logger.logError(sprintf('Data parsing failed: %s', ME.message));
                rethrow(ME);
            end
        end
        
        function batchData = readFilesBatch(obj, filePaths, protocolInfos)
            %READFILESBATCH Read multiple files efficiently
            %   Optimized for parallel processing when available
            
            numFiles = length(filePaths);
            obj.logger.logInfo(sprintf('Starting batch read of %d files', numFiles));
            
            batchData = cell(numFiles, 1);
            
            if obj.config.processing.useParallel && numFiles > 1
                % Parallel batch reading
                batchData = obj.readFilesBatchParallel(filePaths, protocolInfos);
            else
                % Sequential batch reading  
                batchData = obj.readFilesBatchSequential(filePaths, protocolInfos);
            end
        end
    end
    
    methods (Access = private)
        function validateFileForReading(obj, filePath)
            %VALIDATEFILEFORREADING Pre-read file validation
            
            % File existence and permissions
            if ~exist(filePath, 'file')
                error('NanionIOManager:FileNotFound', 'File not found: %s', filePath);
            end
            
            % File size check
            fileInfo = dir(filePath);
            fileSizeMB = fileInfo.bytes / (1024 * 1024);
            
            if fileSizeMB > obj.config.io.maxFileSizeMB
                obj.logger.logWarning(sprintf('Large file detected: %.1f MB', fileSizeMB));
            end
            
            % File format validation
            [~, ~, ext] = fileparts(filePath);
            if ~ismember(lower(ext), {'.xlsx', '.xls'})
                error('NanionIOManager:UnsupportedFormat', 'Unsupported file format: %s', ext);
            end
            
            obj.logger.logInfo(sprintf('File validation passed: %.1f MB %s file', fileSizeMB, ext));
        end
        
        function validateRawData(obj, rawData, filePath)
            %VALIDATERAWDATA Post-read data validation
            
            if isempty(rawData)
                error('NanionIOManager:EmptyFile', 'File contains no data: %s', filePath);
            end
            
            if size(rawData, 1) < 10
                error('NanionIOManager:InsufficientData', 'File has too few rows (%d): %s', ...
                    size(rawData, 1), filePath);
            end
            
            if size(rawData, 2) < 20
                error('NanionIOManager:InsufficientColumns', 'File has too few columns (%d): %s', ...
                    size(rawData, 2), filePath);
            end
            
            % Check for reasonable data density
            nonEmptyCells = sum(~cellfun(@isempty, rawData(:)));
            totalCells = numel(rawData);
            dataDensity = nonEmptyCells / totalCells;
            
            if dataDensity < 0.1
                obj.logger.logWarning(sprintf('Low data density (%.1f%%) in file', dataDensity * 100));
            end
            
            obj.logger.logInfo(sprintf('Data validation passed: %.1f%% density', dataDensity * 100));
        end
        
        function headerInfo = findHeaderStructure(obj, rawData)
            %FINDHEADERSTRUCTURE Locate header rows in data
            %   Simple approach: look for known header text
            
            headerRow1Idx = [];
            headerRow2Idx = [];
            
            % Search for "Sweep Results" and "Parameter" in column 1
            for row = 1:min(15, size(rawData, 1))
                cellValue = rawData{row, 1};
                
                if ischar(cellValue) || isstring(cellValue)
                    cellText = char(cellValue);
                    
                    if contains(cellText, 'Sweep Results', 'IgnoreCase', true)
                        headerRow1Idx = row;
                    elseif contains(cellText, 'Parameter', 'IgnoreCase', true)
                        headerRow2Idx = row;
                    end
                end
            end
            
            % Validate we found both headers
            if isempty(headerRow1Idx) || isempty(headerRow2Idx)
                error('NanionIOManager:HeadersNotFound', ...
                    'Could not find "Sweep Results" or "Parameter" headers in file');
            end
            
            headerInfo = struct(...
                'headerRow1Idx', headerRow1Idx, ...     % "Sweep Results" row
                'headerRow2Idx', headerRow2Idx, ...     % "Parameter" row  
                'dataStartRow', headerRow2Idx + 2);     % Data starts 2 rows after "Parameter"
            
            obj.logger.logInfo(sprintf('Found headers: "Sweep Results" at row %d, "Parameter" at row %d, data starts row %d', ...
                headerRow1Idx, headerRow2Idx, headerInfo.dataStartRow));
        end
        
        function headers = extractHeaders(obj, rawData, headerInfo)
            %EXTRACTHEADERS Extract and clean header information - ultra simple
            
            % Just use generic column names for Phase 1
            numCols = size(rawData, 2);
            
            % Create simple headers
            combinedHeaders = cell(1, numCols);
            for i = 1:numCols
                combinedHeaders{i} = sprintf('Col_%d', i);
            end
            
            headers = struct(...
                'row1', {}, ...
                'row2', {}, ...
                'combined', combinedHeaders);
            
            obj.logger.logInfo(sprintf('Generated %d simple column headers (Col_1, Col_2, etc.)', numCols));
        end
        
        function cleanRow = cleanHeaderRow(obj, rawRow)
            %CLEANHEADERROW Clean and standardize header row - simplified
            
            cleanRow = cell(size(rawRow));
            
            for i = 1:length(rawRow)
                cellValue = rawRow{i};
                
                if isempty(cellValue)
                    cleanRow{i} = '';
                elseif isnumeric(cellValue)
                    cleanRow{i} = num2str(cellValue);
                elseif ischar(cellValue) || isstring(cellValue)
                    cleanRow{i} = char(strtrim(string(cellValue)));
                else
                    cleanRow{i} = '';
                end
            end
        end
        
        function header = createValidTableHeader(obj, row1Val, row2Val, colIdx)
            %CREATEVALIDTABLEHEADER Create valid MATLAB table header
            
            % Ensure inputs are strings
            if isempty(row1Val) || ismissing(row1Val)
                row1Val = '';
            else
                row1Val = char(row1Val);
            end
            
            if isempty(row2Val) || ismissing(row2Val)
                row2Val = '';
            else
                row2Val = char(row2Val);
            end
            
            % Simple combination
            if isempty(row1Val) && isempty(row2Val)
                header = sprintf('Column_%d', colIdx);
            else
                combined = strtrim([row1Val, '_', row2Val]);
                
                % Make valid MATLAB variable name - simple approach
                header = regexprep(combined, '[^a-zA-Z0-9_]', '_');
                
                % Ensure it starts with letter
                if ~isempty(header) && ~isletter(header(1))
                    header = ['Col_', header];
                end
                
                % Ensure it's not empty
                if isempty(header)
                    header = sprintf('Column_%d', colIdx);
                end
            end
        end
        
        function dataTable = createDataTable(obj, rawData, headerInfo, headers)
            %CREATEDATATABLE Create MATLAB table from raw data
            
            % Extract data portion
            dataRows = rawData(headerInfo.dataStartRow:end, :);
            
            % Ensure headers and data columns match
            numDataCols = size(dataRows, 2);
            numHeaderCols = length(headers.combined);
            
            obj.logger.logInfo(sprintf('Data columns: %d, Header columns: %d', numDataCols, numHeaderCols));
            
            if numDataCols > numHeaderCols
                % Trim data to header length
                dataRows = dataRows(:, 1:numHeaderCols);
                obj.logger.logInfo(sprintf('Trimmed data to %d columns to match headers', numHeaderCols));
            elseif numHeaderCols > numDataCols
                % Trim headers to data length
                headers.combined = headers.combined(1:numDataCols);
                obj.logger.logInfo(sprintf('Trimmed headers to %d columns to match data', numDataCols));
            end
            
            % Create table with simple approach
            try
                dataTable = array2table(dataRows, 'VariableNames', headers.combined);
                obj.logger.logInfo(sprintf('✓ Table created successfully: %dx%d', size(dataTable)));
            catch ME
                obj.logger.logError(sprintf('Table creation failed: %s', ME.message));
                
                % Fallback: create generic headers that definitely work
                numCols = size(dataRows, 2);
                genericHeaders = arrayfun(@(x) sprintf('Col_%d', x), 1:numCols, 'UniformOutput', false);
                
                obj.logger.logInfo('Using generic column headers as fallback');
                dataTable = array2table(dataRows, 'VariableNames', genericHeaders);
            end
        end
        
        function batchData = readFilesBatchSequential(obj, filePaths, protocolInfos)
            %READFILESBATCHSEQUENTIAL Sequential batch processing
            
            numFiles = length(filePaths);
            batchData = cell(numFiles, 1);
            
            for i = 1:numFiles
                try
                    obj.logger.logInfo(sprintf('Reading file %d/%d', i, numFiles));
                    
                    rawData = obj.readFile(filePaths{i});
                    parsedData = obj.parseData(rawData, protocolInfos{i});
                    
                    batchData{i} = struct(...
                        'status', 'success', ...
                        'filePath', filePaths{i}, ...
                        'data', parsedData);
                    
                    % Memory cleanup for large batches
                    if mod(i, obj.config.processing.memoryCleanupInterval) == 0
                        obj.logger.logInfo('Performing memory cleanup...');
                        java.lang.System.gc();
                    end
                    
                catch ME
                    obj.logger.logError(sprintf('Failed to read file %d: %s', i, ME.message));
                    
                    batchData{i} = struct(...
                        'status', 'failed', ...
                        'filePath', filePaths{i}, ...
                        'error', ME.message);
                end
            end
        end
        
        function batchData = readFilesBatchParallel(obj, filePaths, protocolInfos)
            %READFILESBATCHPARALLEL Parallel batch processing
            
            obj.logger.logInfo('Starting parallel file reading...');
            
            numFiles = length(filePaths);
            batchData = cell(numFiles, 1);
            
            % Check parallel pool availability - FAIL if not available
            pool = gcp('nocreate');
            if isempty(pool)
                error('NanionIOManager:NoParallelPool', ...
                    'Parallel processing requested but no parallel pool available');
            end
            
            futures = parallel.FevalFuture.empty(numFiles, 0);
            
            for i = 1:numFiles
                futures(i) = parfeval(pool, @obj.readSingleFileStatic, 1, ...
                    filePaths{i}, protocolInfos{i}, obj.config);
            end
            
            % Collect results
            for i = 1:numFiles
                try
                    batchData{i} = fetchOutputs(futures(i));
                    batchData{i}.status = 'success';
                catch ME
                    batchData{i} = struct(...
                        'status', 'failed', ...
                        'filePath', filePaths{i}, ...
                        'error', ME.message);
                end
            end
        end
        
        function isEmpty = isEmptyCell(obj, cellValue)
            %ISEMPTYCELL Check if cell value is empty
            
            isEmpty = isempty(cellValue) || ...
                      (isnumeric(cellValue) && isnan(cellValue)) || ...
                      (ischar(cellValue) && isempty(strtrim(cellValue))) || ...
                      (isstring(cellValue) && (ismissing(cellValue) || strtrim(cellValue) == ""));
        end
        
        function fileName = getFileName(obj, filePath)
            %GETFILENAME Extract filename from path
            [~, fileName, ext] = fileparts(filePath);
            fileName = [fileName, ext];
        end
    end
    
    methods (Static)
        function result = readSingleFileStatic(filePath, protocolInfo, config)
            %READSINGLEFILESTATIC Static method for parallel processing
            
            % Create temporary logger (no shared state in parallel)
            tempLogger = NanionLogger(config);
            tempIO = NanionIOManager(config, tempLogger);
            
            rawData = tempIO.readFile(filePath);
            parsedData = tempIO.parseData(rawData, protocolInfo);
            
            result = struct(...
                'filePath', filePath, ...
                'data', parsedData);
        end
    end
end